// serverDiscord.js

// Importa y carga las variables de entorno desde el archivo .env
require('dotenv').config();

// Importa los m√≥dulos necesarios
const express = require('express');
const bodyParser = require('body-parser'); // Middleware para procesar cuerpos de petici√≥n JSON
const nodemailer = require('nodemailer'); // Para el env√≠o de correos electr√≥nicos
const { Client, GatewayIntentBits } = require('discord.js'); // Para interactuar con la API de Discord
const fetch = require('node-fetch'); // Para hacer peticiones HTTP desde el backend (ej. a JSON Server)

// Inicializa la aplicaci√≥n Express
const app = express();
// Define el puerto del servidor Express. Prioriza la variable de entorno PORT, si no, usa 3001.
const PORT = process.env.PORT || 3001; 

// --- Middlewares (Funciones que se ejecutan antes de que la petici√≥n llegue a la ruta) ---

// Configura bodyParser para procesar cuerpos de petici√≥n en formato JSON
app.use(bodyParser.json()); 

// Configura CORS (Cross-Origin Resource Sharing)
// Esto es VITAL para permitir que tu frontend (ejecut√°ndose en un puerto diferente como 5500)
// pueda hacer peticiones a este servidor Express.
app.use((req, res, next) => {
    // Permite peticiones desde cualquier origen ('*'). ¬°En producci√≥n, c√°mbialo a tu dominio espec√≠fico!
    // Ej: 'http://localhost:5500' para Live Server, o 'https://tusitioweb.com' cuando est√© en l√≠nea.
    res.header('Access-Control-Allow-Origin', '*'); 
    // Define los m√©todos HTTP permitidos (GET, POST, PUT, DELETE, OPTIONS)
    res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS'); 
    // Define las cabeceras permitidas en las peticiones
    res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization'); 
    
    // Maneja las peticiones de pre-vuelo (OPTIONS), que los navegadores env√≠an antes de peticiones complejas
    if (req.method === 'OPTIONS') {
        return res.sendStatus(200); // Responde un 200 OK inmediatamente para las peticiones OPTIONS
    }
    next(); // Pasa la petici√≥n al siguiente middleware o a la ruta correspondiente
});

// --- Configuraci√≥n e Inicializaci√≥n del Bot de Discord ---

// Obtiene el token y el ID del canal desde las variables de entorno
const DISCORD_BOT_TOKEN = process.env.DISCORD_BOT_TOKEN;
const DISCORD_CHANNEL_ID = process.env.DISCORD_CHANNEL_ID;

// Crea una nueva instancia del cliente de Discord, especificando las "intenciones" necesarias
const discordClient = new Client({ 
    intents: [
        GatewayIntentBits.Guilds, // Necesario para acceder a informaci√≥n de servidores (guilds)
        GatewayIntentBits.MessageContent // Necesario para que el bot pueda enviar y recibir contenido de mensajes
                                        // (aunque solo enviaremos, Discord lo requiere para interactuar con mensajes)
    ] 
});

// Solo intenta iniciar sesi√≥n si el token de Discord est√° configurado
if (DISCORD_BOT_TOKEN) {
    // Evento 'ready': se dispara una vez que el bot se conecta exitosamente a Discord
    discordClient.once('ready', () => {
        console.log(`[Discord Bot] ${discordClient.user.tag} est√° en l√≠nea!`);
    });

    // Intenta iniciar sesi√≥n del bot en Discord
    discordClient.login(DISCORD_BOT_TOKEN)
        .catch(error => console.error("[Discord Bot] Error al iniciar sesi√≥n en Discord:", error));
} else {
    console.warn("[Discord Bot] DISCORD_BOT_TOKEN no configurado en .env. Las notificaciones de Discord no funcionar√°n.");
}

// --- Configuraci√≥n e Inicializaci√≥n de Nodemailer para Env√≠o de Correos ---

// Obtiene las credenciales de correo desde las variables de entorno
const EMAIL_USER = process.env.EMAIL_USER;
const EMAIL_PASS = process.env.EMAIL_PASS;

// Crea un "transporter" de Nodemailer, que es el objeto que se encarga de enviar correos
const transporter = nodemailer.createTransport({
    service: 'gmail', // Configura para usar el servicio de Gmail (puedes cambiarlo si usas otro)
    auth: {
        user: EMAIL_USER, // Tu correo electr√≥nico
        pass: EMAIL_PASS  // Tu contrase√±a (o contrase√±a de aplicaci√≥n si usas 2FA en Gmail)
    }
});

// Advierte si las credenciales de correo no est√°n configuradas
if (!EMAIL_USER || !EMAIL_PASS) {
    console.warn("[Email Notifier] EMAIL_USER o EMAIL_PASS no configurados en .env. Las notificaciones por correo no funcionar√°n.");
}


// --- Endpoints de la API (Rutas que tu frontend llamar√°) ---

// Endpoint POST para manejar las suscripciones a tu bolet√≠n
// Llamado desde el formulario de suscripci√≥n en home.js
app.post('/subscribe', async (req, res) => {
    const { email } = req.body; // Extrae el correo electr√≥nico del cuerpo de la petici√≥n

    // Valida que el email no est√© vac√≠o
    if (!email) {
        return res.status(400).json({ message: 'Email es requerido para la suscripci√≥n.' });
    }

    try {
        // 1. Guardar el email del suscriptor en JSON Server
        // Esta petici√≥n POST guarda el nuevo suscriptor en la colecci√≥n 'suscriptores' de db.json
        const saveResponse = await fetch('http://localhost:3000/suscriptores', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ email: email, fechaSuscripcion: new Date().toISOString() }) // A√±ade fecha
        });

        // Si la respuesta de JSON Server no es exitosa (ej. 4xx, 5xx), lanza un error
        if (!saveResponse.ok) {
            throw new Error(`Error al guardar suscriptor en JSON Server: ${saveResponse.status} - ${saveResponse.statusText}`);
        }
        const newSubscriber = await saveResponse.json(); // Parsea la respuesta de JSON Server
        console.log(`[Suscripci√≥n] Nuevo suscriptor guardado en db.json: ${newSubscriber.email}`);

        // 2. Enviar notificaci√≥n al canal de Discord del administrador
        // Solo intenta enviar si el bot de Discord est√° en l√≠nea y el ID del canal est√° configurado
        if (discordClient.isReady() && DISCORD_CHANNEL_ID) {
            try {
                // Intenta obtener el objeto del canal por su ID
                const channel = await discordClient.channels.fetch(DISCORD_CHANNEL_ID);
                // Verifica que el canal exista y sea un canal de texto
                if (channel && channel.isTextBased()) {
                    // Env√≠a el mensaje de notificaci√≥n al canal de Discord
                    await channel.send(`üéâ ¬°Nueva suscripci√≥n en Medell√≠n Sounds! Correo: **${email}**`);
                    console.log(`[Discord] Notificaci√≥n de nueva suscripci√≥n enviada.`);
                } else {
                    console.warn(`[Discord] Canal de Discord no encontrado o no es de texto con ID: ${DISCORD_CHANNEL_ID}. Verifique ID y permisos.`);
                }
            } catch (discordError) {
                // Aqu√≠ NO lanzamos el error. Solo lo registramos.
                // Esto permite que la suscripci√≥n se marque como exitosa para el usuario final,
                // incluso si hubo un problema menor o transitorio con Discord.
                console.error("[Discord] Error al intentar enviar mensaje a Discord (posiblemente un problema secundario):", discordError.message);
            }
        } else {
            console.warn("[Discord] Cliente de Discord no est√° listo o DISCORD_CHANNEL_ID no configurado, no se pudo intentar enviar notificaci√≥n.");
        }

        // Si todo lo anterior (guardar en JSON Server y el intento de Discord) fue bien,
        // env√≠a una respuesta de √©xito al frontend (home.js).
        res.status(200).json({ message: 'Suscripci√≥n exitosa y notificaci√≥n enviada.' });

    } catch (error) {
        // Este bloque catch maneja errores cr√≠ticos (ej. fallo al conectar con JSON Server)
        // y env√≠a una respuesta de error al frontend.
        console.error('‚ùå Error en el endpoint /subscribe:', error.message);
        res.status(500).json({ message: 'Error interno del servidor al procesar la suscripci√≥n.' });
    }
});

// Endpoint POST para manejar la publicaci√≥n/actualizaci√≥n de un evento
// Llamado desde el panel de administraci√≥n (admin.js) despu√©s de guardar un evento
app.post('/publish-event', async (req, res) => {
    const event = req.body; // El objeto del evento completo enviado desde el frontend del admin

    // Valida que los datos esenciales del evento est√©n presentes
    if (!event || !event.titulo || !event.descripcion || !event.imagen) {
        return res.status(400).json({ message: 'Datos del evento incompletos para publicar notificaci√≥n.' });
    }

    try {
        // En este punto, asumimos que el evento ya ha sido guardado/actualizado en db.json
        // por el script de administraci√≥n (admin.js) directamente.
        // Si no fuera as√≠, podr√≠as agregar aqu√≠ la l√≥gica para guardar el evento en JSON Server.

        // 1. Obtener todos los suscriptores de JSON Server para enviarles correos
        const suscriptoresResponse = await fetch('http://localhost:3000/suscriptores');
        if (!suscriptoresResponse.ok) {
            throw new Error(`Error al obtener suscriptores de JSON Server: ${suscriptoresResponse.status}`);
        }
        const suscriptores = await suscriptoresResponse.json();
        const emails = suscriptores.map(s => s.email).filter(Boolean); // Extrae solo los correos v√°lidos de la lista

        // Si no hay suscriptores, no es necesario enviar correos
        if (emails.length === 0) {
            console.log('[Publish Event] No hay suscriptores para enviar correos.');
            return res.status(200).json({ message: 'Notificaci√≥n de evento procesada. No hay suscriptores para notificar por correo.' });
        }

        // 2. Enviar correo a cada suscriptor usando Nodemailer
        const mailOptions = {
            from: EMAIL_USER, // El remitente del correo (tu email configurado en .env)
            to: emails.join(', '), // Los destinatarios (todos los suscriptores, separados por coma)
            subject: `üéâ ¬°Nuevo Evento en Medell√≠n Sounds: ${event.titulo}!`, // Asunto del correo
            html: `
                <div style="font-family: Arial, sans-serif; line-height: 1.6; color: #333;">
                    <h2 style="color: #0599b3;">¬°No te pierdas este nuevo evento!</h2>
                    <h3>${event.titulo}</h3>
                    <img src="${event.imagen}" alt="${event.titulo}" style="max-width: 100%; height: auto; display: block; margin-bottom: 20px;">
                    <p>${event.descripcion}</p>
                    <p><strong>Fecha:</strong> ${event.fecha}</p>
                    <p><strong>Hora:</strong> ${event.hora}</p>
                    <p><strong>Lugar:</strong> ${event.lugar}</p>
                    ${event.precio ? `<p><strong>Precio:</strong> $${parseInt(event.precio).toLocaleString('es-CO')}</p>` : ''}
                    <p style="margin-top: 20px;">¬°Te esperamos!</p>
                    <p><a href="http://localhost:5500/index.html" style="display: inline-block; padding: 10px 20px; background-color: #0599b3; color: white; text-decoration: none; border-radius: 5px;">Visita nuestra web para m√°s detalles</a></p>
                    <p style="font-size: 0.9em; color: #666; margin-top: 30px;">Este correo fue enviado porque te suscribiste a nuestras notificaciones de eventos musicales.</p>
                </div>
            ` // Contenido HTML del correo
        };

        // Intenta enviar el correo
        await transporter.sendMail(mailOptions);
        console.log(`[Email Notifier] Correos de notificaci√≥n de evento "${event.titulo}" enviados exitosamente a ${emails.length} suscriptores.`);

        // Si el env√≠o fue exitoso, env√≠a una respuesta de √©xito al frontend del admin
        res.status(200).json({ message: 'Notificaci√≥n de evento procesada y correos enviados.' });

    } catch (error) {
        // Manejo de errores para este endpoint
        console.error('‚ùå Error en el endpoint /publish-event:', error.message);
        res.status(500).json({ message: 'Error interno del servidor al procesar la publicaci√≥n del evento.' });
    }
});


// Inicia el servidor Express
// app.listen() hace que el servidor comience a escuchar peticiones en el puerto especificado
app.listen(PORT, () => {
    console.log(`Servidor Express corriendo en http://localhost:${PORT}`);
    console.log(`Aseg√∫rate de que JSON Server tambi√©n est√© corriendo en http://localhost:3000`);
});